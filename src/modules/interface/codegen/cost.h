// -----------------------------------------------------------------------------
// This file was autogenerated by symforce from template:
//     function/FUNCTION.h.jinja
// Do NOT modify by hand.
// -----------------------------------------------------------------------------

#pragma once


#include <Eigen/Dense>



namespace sym {


/**
* This function was autogenerated from a symbolic function. Do not modify by hand.
*
* Symbolic function: cost_symfn
*
* Args:
*     p: Matrix31
*     v: Matrix31
*     w: Matrix31
*     p_d: Matrix31
*     v_d: Matrix31
*     w_d: Matrix31
*     thrust: Scalar
*     torque: Matrix31
*     Qp: Scalar
*     Qv: Scalar
*     Qw: Scalar
*     Qthrust: Scalar
*     Qtorque: Scalar
*
* Outputs:
*     cost: Scalar
*     jacobian: (1x13) jacobian of cost wrt args p (3), v (3), w (3), thrust (1), torque (3)
*/
template <typename Scalar>
void Cost(const Eigen::Matrix<Scalar, 3, 1>& p, const Eigen::Matrix<Scalar, 3, 1>& v, const Eigen::Matrix<Scalar, 3, 1>& w, const Eigen::Matrix<Scalar, 3, 1>& p_d, const Eigen::Matrix<Scalar, 3, 1>& v_d, const Eigen::Matrix<Scalar, 3, 1>& w_d, const Scalar thrust, const Eigen::Matrix<Scalar, 3, 1>& torque, const Scalar Qp, const Scalar Qv, const Scalar Qw, const Scalar Qthrust, const Scalar Qtorque, Scalar* const cost = nullptr, Eigen::Matrix<Scalar, 1, 13>* const jacobian = nullptr) {

    // Total ops: 62

    // Input arrays

    // Intermediate terms (14)
    const Scalar _tmp0 = w(1, 0) - w_d(1, 0);
    const Scalar _tmp1 = w(0, 0) - w_d(0, 0);
    const Scalar _tmp2 = w(2, 0) - w_d(2, 0);
    const Scalar _tmp3 = p(2, 0) - p_d(2, 0);
    const Scalar _tmp4 = p(0, 0) - p_d(0, 0);
    const Scalar _tmp5 = p(1, 0) - p_d(1, 0);
    const Scalar _tmp6 = v(1, 0) - v_d(1, 0);
    const Scalar _tmp7 = v(2, 0) - v_d(2, 0);
    const Scalar _tmp8 = v(0, 0) - v_d(0, 0);
    const Scalar _tmp9 = Scalar(1.0);
    const Scalar _tmp10 = Qp*_tmp9;
    const Scalar _tmp11 = Qv*_tmp9;
    const Scalar _tmp12 = Qw*_tmp9;
    const Scalar _tmp13 = Qtorque*_tmp9;

    // Output terms (2)
    if ( cost != nullptr ) {
        Scalar& _cost = (*cost);


        _cost = Scalar(0.5)*Qp*(std::pow(_tmp3, Scalar(2)) + std::pow(_tmp4, Scalar(2)) + std::pow(_tmp5, Scalar(2))) + Scalar(0.5)*Qthrust*std::pow(thrust, Scalar(2)) + Scalar(0.5)*Qtorque*(std::pow(torque(0, 0), Scalar(2)) + std::pow(torque(1, 0), Scalar(2)) + std::pow(torque(2, 0), Scalar(2))) + Scalar(0.5)*Qv*(std::pow(_tmp6, Scalar(2)) + std::pow(_tmp7, Scalar(2)) + std::pow(_tmp8, Scalar(2))) + Scalar(0.5)*Qw*(std::pow(_tmp0, Scalar(2)) + std::pow(_tmp1, Scalar(2)) + std::pow(_tmp2, Scalar(2)));
    }

    if ( jacobian != nullptr ) {
        Eigen::Matrix<Scalar, 1, 13>& _jacobian = (*jacobian);


        _jacobian(0, 0) = _tmp10*_tmp4;
        _jacobian(0, 1) = _tmp10*_tmp5;
        _jacobian(0, 2) = _tmp10*_tmp3;
        _jacobian(0, 3) = _tmp11*_tmp8;
        _jacobian(0, 4) = _tmp11*_tmp6;
        _jacobian(0, 5) = _tmp11*_tmp7;
        _jacobian(0, 6) = _tmp1*_tmp12;
        _jacobian(0, 7) = _tmp0*_tmp12;
        _jacobian(0, 8) = _tmp12*_tmp2;
        _jacobian(0, 9) = Qthrust*_tmp9*thrust;
        _jacobian(0, 10) = _tmp13*torque(0, 0);
        _jacobian(0, 11) = _tmp13*torque(1, 0);
        _jacobian(0, 12) = _tmp13*torque(2, 0);
    }
}  // NOLINT(readability/fn_size)

// NOLINTNEXTLINE(readability/fn_size)
}  // namespace sym
